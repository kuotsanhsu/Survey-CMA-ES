<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>CMA-ES Demo</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://d3js.org/d3-contour.v1.min.js"></script>
  <script src="https://d3js.org/d3-random.v2.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.6.4/math.min.js"></script>
  <style>
/* * {
  margin: 0;
  padding: 0;
} */
#layers {
  position: relative;
}
#layer-contour {
  border: 1px solid black;
/*   transform-origin: 0 0; */
/*   transform: scale(1.2); */
}
#layer-samples {
  position: absolute;
  left: 1px;
  top: 1px;
  z-index: 100;
}
input[type=number] {
  width: 60px;
}
  </style>
</head>
<body>
  <div id="layers">
    <canvas id="layer-contour" width="800" height="600"></canvas>
    <canvas id="layer-samples" width="800" height="600"></canvas>
<!--     <canvas id="strip" width="50" height = "600"></canvas> -->
  </div>
    
  <form id="control" action="javascript:void(0);">
    <label for="levels">Levels (10-50):</label>
    <input id="levels" name="levels" type="range" list="levels-list" min="10" max="50" step="5" value="20" required />
    <datalist id="levels-list">
      <option value="10"></option>
      <option value="20"></option>
      <option value="30"></option>
      <option value="40"></option>
      <option value="50"></option>
    </datalist>

    <label for="strokeWidth">Stroke width (0-1):</label>
    <input id="strokeWidth" name="strokeWidth" type="range" list="strokeWidth-list" min="0.1" max="1" step="0.1" value="0.3" required />
    <datalist id="strokeWidth-list">
      <option value="0.0"></option>
      <option value="0.2"></option>
      <option value="0.4"></option>
      <option value="0.6"></option>
      <option value="0.8"></option>
      <option value="1.0"></option>
    </datalist>
    
    <label for="strokeColor">Stroke color:</label>
    <input id="strokeColor" name="strokeColor" type="color" value="#ffffff" required />
    
    <br/>

    <label for="scaling">Scaling:</label>
    <select id="scaling">
      <option data-threshold="scaleLinear" data-color="scaleSequential" selected>Linear</option>
      <option data-threshold="scaleLog" data-color="scaleSequentialLog">Logarithmic</option>
      <option data-threshold="scalePow" data-color="scaleSequentialPow">Exponential</option>
      <option data-threshold="scaleSymlog" data-color="scaleSequentialSymlog">Bi-symmetrical logarithmic</option>
      <option data-threshold="scaleSqrt" data-color="scaleSequentialSqrt">Square root</option>
    </select>

    <label for="hue">Hue:</label>
    <select id="hue">
      <option value="interpolateBlues">Blue</option>
      <option value="interpolateGreens">Green</option>
      <option value="interpolateGreys">Grey</option>
      <option value="interpolateOranges" selected>Orange</option>
      <option value="interpolatePurples">Purple</option>
      <option value="interpolateReds">Red</option>
      <option value="interpolateBuGn">Blue-Green</option>
      <option value="interpolateBuPu">Blue-Purple</option>
      <option value="interpolateGnBu">Green-Blue</option>
      <option value="interpolateOrRd">Orange-Red</option>
      <option value="interpolatePuBu">Purble-Blue</option>
      <option value="interpolatePuRd">Purble-Red</option>
      <option value="interpolateRdPu">Red-Purple</option>
      <option value="interpolateYlGn">Yellow-Green</option>
      <option value="interpolatePuBuGn">Purple-Blue-Green</option>
      <option value="interpolateYlGnBu">Yellow-Green-Blue</option>
      <option value="interpolateYlOrBr">Yellow-Orange-Blue</option>
      <option value="interpolateYlOrRd">Yellow-Orange-Red</option>
      <option value="interpolateTurbo">Turbo</option>
      <option value="interpolateViridis">Viridis</option>
      <option value="interpolateInferno">Inferno</option>
      <option value="interpolateMagma">Magma</option>
      <option value="interpolatePlasma">Plasma</option>
      <option value="interpolateCividis">Cividis</option>
      <option value="interpolateWarm">Warm</option>
      <option value="interpolateCool">Cool</option>
      <option value="interpolateCubehelixDefault">Cubehelix</option>
      <option value="interpolateBrBG">Brown-Green</option>
      <option value="interpolatePRGn">Purple-Green</option>
      <option value="interpolatePiYG">Pink-Green</option>
      <option value="interpolatePuOr">Purple-Orange</option>
      <option value="interpolateRdBu">Red-Blue</option>
      <option value="interpolateRdGy">Red-Grey</option>
      <option value="interpolateRdYlBu">Red-Yellow-Blue</option>
      <option value="interpolateRdYlGn">Red-Yellow-Green</option>
      <option value="interpolateSpectral">Spectral</option>
      <option value="interpolateRainbow">Rainbow</option>
      <option value="interpolateSinebow">Sinebow</option>
    </select>

    <input type="reset" />
  </form>

  <form id="func" action="javascript:void(0);">
    <label for="xmin">x min:</label>
    <input id="xmin" name="xmin" type="number" value="-3" required />

    <label for="xmax">x max:</label>
    <input id="xmax" name="xmax" type="number" value="1" required />

    <label for="ymin">y min:</label>
    <input id="ymin" name="ymin" type="number" value="-2" required />

    <label for="ymax">y max:</label>
    <input id="ymax" name="ymax" type="number" value="1" required />
    
    <label for="objective">Function:</label>
    <select id="objective">
      <option value="Ackley" selected>Ackley</option>
      <option value="GoldsteinPrice">Goldstein-Price</option>
    </select>

    <input id="plot" name="plot" type="submit" value="Plot" />
  </form>
  <script>
const canvas = document.getElementById('layer-contour');
const ctx = canvas.getContext('2d', {alpha: false});
const path = d3.geoPath().context(ctx);
const strokeWidth = document.getElementById('strokeWidth');
const strokeColor = document.getElementById('strokeColor');
let color, G;

function draw() {
  ctx.lineWidth = strokeWidth.value;
  ctx.strokeStyle = strokeColor.value;
  for (g of G) {
    ctx.beginPath();
    path(g);
    ctx.fillStyle = color(g.value);
    ctx.fill();
    ctx.stroke();
  }
}
strokeWidth.onchange = draw;
strokeColor.onchange = draw;

let scale = {}, z = {};

const hue = document.getElementById('hue');
hue.onchange = function() {
  const sel = this.options[this.selectedIndex];
  color = scale.color(z.extent, d3[sel.value]);
  draw();
};

const levels = document.getElementById('levels');

function measure() {
  const contours = parseInt(levels.value);
  const threshold = scale.threshold(z.extent, [0, contours]);
  G = d3
    .contours()
    .size([z.width, z.height])
    .thresholds(d3.range(contours).map(i => threshold.invert(i)))
    (z.values);
  hue.onchange();
}
levels.onchange = measure;

const scaling = document.getElementById('scaling');
scaling.onchange = function() {
  const sel = this.options[this.selectedIndex];
  scale.threshold = d3[sel.getAttribute('data-threshold')];
  scale.color = d3[sel.getAttribute('data-color')];
  measure();
};

const func = document.getElementById('func');
func.onsubmit = function() {
  const objectives = {
    GoldsteinPrice: (x, y) => ((1 + Math.pow(x + y + 1, 2) * (19 - 14 * x + 3 * x * x - 14 * y + 6 * x * x + 3 * y * y)) * (30 + Math.pow(2 * x - 3 * y, 2) * (18 - 32 * x + 12 * x * x + 48 * y - 36 * x * y + 27 * y * y))),
    Ackley: (x, y) => (20 + Math.E - 20 * Math.exp(-0.2 * Math.sqrt(0.5 * (x * x + y * y))) - Math.exp(0.5 * (Math.cos(2 * Math.PI * x) + Math.sin(2 * Math.PI * y)))),
  };
  const objective = this.objective;
  const f = objectives[objective.options[objective.selectedIndex].value];
  
  const xmin = parseInt(this.xmin.value);
  const ymin = parseInt(this.ymin.value);
  const dx = parseInt(this.xmax.value) - xmin;
  if (dx <= 0) {
    alert('Invalid x values');
    return;
  }
  const dy = parseInt(this.ymax.value) - ymin;
  if (dy <= 0) {
    alert('Invalid y values');
    return;
  }
  const ratio = Math.max(dx / canvas.width, dy / canvas.height);
  
  z.width = parseInt(Math.floor(dx / ratio));
  z.height = parseInt(Math.floor(dy / ratio));
  z.values = new Array(z.width * z.height);
  for (let row = z.height, n = 0; row--;) {
    for (let col = 0; col < z.width; ++col, ++n) {
      z.values[n] = f(xmin + col * ratio, ymin + row * ratio);
    }
  }
  z.extent = d3.extent(z.values);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  scaling.onchange();
};

func.onsubmit();
  </script>
  <script>
const layerSamples = {};
layerSamples.canvas = document.getElementById('layer-samples');
layerSamples.ctx = layerSamples.canvas.getContext('2d');


const N = 20;
const randx = d3.randomInt(layerSamples.canvas.width);
const randy = d3.randomInt(layerSamples.canvas.height);

function drawCircle(x, y, r) {
  layerSamples.ctx.beginPath();
  layerSamples.ctx.arc(x, y, r, 0, 2 * Math.PI);
  layerSamples.ctx.fill();
}

for (let n = 0; n < N; ++n) {
  drawCircle(randx(), randy(), 10);
}

const dimension;

class Generation {
  constructor(population, origin, objective) {
    this.N = population;
    this.m = origin;
    this.C = math.identity(dimension);
    this.p = math.zeros(dimension);
    this.q = math.zeros(dimension);
    this.s = 1;
    this.stdn = d3.randomNormal();
  }

  evolve() {}
}

class CMA_ES {
  constructor(population, origin, objective) {
    this.N = population;
    this.m = origin;
    this.f = objective;
    this.C = math.identity(2);
    this.p = math.zeros(2);
    this.q = math.zeros(2);
    this.s = 1;
    this.stdn = d3.randomNormal();
  }

  evolve() {
    const A = math.sqrtm(this.C);
    const z = d3.range(this.N).map(_ => math.multiply(A, [this.stdn(), this.stdn()]));
    
  }
  next() {}
  prev() {}
}
  </script>
</body>
</html>